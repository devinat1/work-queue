{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 18, "column": 0}, "map": {"version":3,"sources":["file:///Users/devinat1/Desktop/projects/work-queue/packages/db-client/src/index.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nimport { PrismaPg } from \"@prisma/adapter-pg\";\nimport { Pool } from \"pg\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nfunction createPrismaClient(): PrismaClient {\n  const connectionString = process.env.POSTGRES_PRISMA_URL;\n\n  if (!connectionString) {\n    throw new Error(\"POSTGRES_PRISMA_URL environment variable is required.\");\n  }\n\n  const pool = new Pool({ connectionString });\n  const adapter = new PrismaPg(pool);\n  return new PrismaClient({ adapter });\n}\n\nexport const prisma = globalForPrisma.prisma ?? createPrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") {\n  globalForPrisma.prisma = prisma;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;;AAEA,MAAM,kBAAkB;AAIxB,SAAS;IACP,MAAM,mBAAmB,QAAQ,GAAG,CAAC,mBAAmB;IAExD,IAAI,CAAC,kBAAkB;QACrB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,OAAO,IAAI,qJAAI,CAAC;QAAE;IAAiB;IACzC,MAAM,UAAU,IAAI,8NAAQ,CAAC;IAC7B,OAAO,IAAI,sMAAY,CAAC;QAAE;IAAQ;AACpC;AAEO,MAAM,SAAS,gBAAgB,MAAM,IAAI;AAEhD,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;AAC3B"}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/devinat1/Desktop/projects/work-queue/apps/web/src/lib/auth.ts"],"sourcesContent":["import { betterAuth } from \"better-auth\";\nimport { prismaAdapter } from \"better-auth/adapters/prisma\";\nimport { prisma } from \"@work-queue/db-client\";\n\nexport const auth = betterAuth({\n  database: prismaAdapter(prisma, {\n    provider: \"postgresql\",\n  }),\n  emailAndPassword: {\n    enabled: true,\n  },\n});\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;;;AAEO,MAAM,OAAO,IAAA,+LAAU,EAAC;IAC7B,UAAU,IAAA,8OAAa,EAAC,2IAAM,EAAE;QAC9B,UAAU;IACZ;IACA,kBAAkB;QAChB,SAAS;IACX;AACF"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///Users/devinat1/Desktop/projects/work-queue/apps/web/helpers/api/auth.ts"],"sourcesContent":["import type { IncomingMessage } from \"http\";\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@work-queue/db-client\";\n\nfunction toHeaders({ req }: { req: IncomingMessage }): Headers {\n  const headerEntries: Record<string, string> = {};\n  for (const [key, value] of Object.entries(req.headers)) {\n    if (value) {\n      headerEntries[key] = Array.isArray(value) ? value.join(\", \") : value;\n    }\n  }\n  return new Headers(headerEntries);\n}\n\nexport async function getSession({ req }: { req: IncomingMessage }) {\n  const session = await auth.api.getSession({\n    headers: toHeaders({ req }),\n  });\n  return session;\n}\n\nexport async function requireAuth({ req }: { req: IncomingMessage }) {\n  const session = await getSession({ req });\n  if (!session) {\n    throw new Error(\"Unauthorized\");\n  }\n  return session;\n}\n\nexport async function requireQueueOwnership({\n  req,\n  shareToken,\n}: {\n  req: IncomingMessage;\n  shareToken: string;\n}) {\n  const session = await requireAuth({ req });\n\n  const queue = await prisma.queue.findUnique({\n    where: { shareToken },\n    select: { userId: true },\n  });\n\n  if (!queue) {\n    throw new Error(\"Queue not found\");\n  }\n\n  if (queue.userId !== session.user.id) {\n    throw new Error(\"Forbidden\");\n  }\n\n  return session;\n}\n\nexport async function isQueueOwner({\n  req,\n  shareToken,\n}: {\n  req: IncomingMessage;\n  shareToken: string;\n}): Promise<boolean> {\n  const session = await getSession({ req });\n  if (!session) {\n    return false;\n  }\n\n  const queue = await prisma.queue.findUnique({\n    where: { shareToken },\n    select: { userId: true },\n  });\n\n  if (!queue) {\n    return false;\n  }\n\n  return queue.userId === session.user.id;\n}\n"],"names":[],"mappings":";;;;;;;;;;AACA;AACA;;;;;;;;AAEA,SAAS,UAAU,EAAE,GAAG,EAA4B;IAClD,MAAM,gBAAwC,CAAC;IAC/C,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,IAAI,OAAO,EAAG;QACtD,IAAI,OAAO;YACT,aAAa,CAAC,IAAI,GAAG,MAAM,OAAO,CAAC,SAAS,MAAM,IAAI,CAAC,QAAQ;QACjE;IACF;IACA,OAAO,IAAI,QAAQ;AACrB;AAEO,eAAe,WAAW,EAAE,GAAG,EAA4B;IAChE,MAAM,UAAU,MAAM,kIAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,UAAU;YAAE;QAAI;IAC3B;IACA,OAAO;AACT;AAEO,eAAe,YAAY,EAAE,GAAG,EAA4B;IACjE,MAAM,UAAU,MAAM,WAAW;QAAE;IAAI;IACvC,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAEO,eAAe,sBAAsB,EAC1C,GAAG,EACH,UAAU,EAIX;IACC,MAAM,UAAU,MAAM,YAAY;QAAE;IAAI;IAExC,MAAM,QAAQ,MAAM,2IAAM,CAAC,KAAK,CAAC,UAAU,CAAC;QAC1C,OAAO;YAAE;QAAW;QACpB,QAAQ;YAAE,QAAQ;QAAK;IACzB;IAEA,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,MAAM,MAAM,KAAK,QAAQ,IAAI,CAAC,EAAE,EAAE;QACpC,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;AACT;AAEO,eAAe,aAAa,EACjC,GAAG,EACH,UAAU,EAIX;IACC,MAAM,UAAU,MAAM,WAAW;QAAE;IAAI;IACvC,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,QAAQ,MAAM,2IAAM,CAAC,KAAK,CAAC,UAAU,CAAC;QAC1C,OAAO;YAAE;QAAW;QACpB,QAAQ;YAAE,QAAQ;QAAK;IACzB;IAEA,IAAI,CAAC,OAAO;QACV,OAAO;IACT;IAEA,OAAO,MAAM,MAAM,KAAK,QAAQ,IAAI,CAAC,EAAE;AACzC"}},
    {"offset": {"line": 185, "column": 0}, "map": {"version":3,"sources":["file:///Users/devinat1/Desktop/projects/work-queue/packages/utils/src/index.ts"],"sourcesContent":["import { randomBytes } from \"crypto\";\n\nexport function generateShareToken(): string {\n  return randomBytes(8).toString(\"base64url\");\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS;IACd,OAAO,IAAA,oHAAW,EAAC,GAAG,QAAQ,CAAC;AACjC"}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":["file:///Users/devinat1/Desktop/projects/work-queue/apps/web/helpers/api/db/queues.ts"],"sourcesContent":["import { prisma } from \"@work-queue/db-client\";\nimport { generateShareToken } from \"@work-queue/utils\";\n\nexport function fetchUserQueues({ userId }: { userId: string }) {\n  return prisma.queue.findMany({\n    where: { userId },\n    include: {\n      _count: {\n        select: { items: true },\n      },\n    },\n    orderBy: { createdAt: \"desc\" },\n  });\n}\n\nexport function fetchQueueByToken({ shareToken }: { shareToken: string }) {\n  return prisma.queue.findUnique({\n    where: { shareToken },\n    include: {\n      items: {\n        orderBy: { position: \"asc\" },\n      },\n    },\n  });\n}\n\nexport function fetchQueueWithUser({ shareToken }: { shareToken: string }) {\n  return prisma.queue.findUnique({\n    where: { shareToken },\n    include: {\n      items: {\n        orderBy: { position: \"asc\" },\n      },\n      user: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\nexport function createQueue({\n  name,\n  userId,\n}: {\n  name: string;\n  userId: string;\n}) {\n  const shareToken = generateShareToken();\n  return prisma.queue.create({\n    data: {\n      name: name.trim(),\n      shareToken,\n      userId,\n    },\n  });\n}\n\nexport function updateQueue({\n  shareToken,\n  name,\n}: {\n  shareToken: string;\n  name: string;\n}) {\n  return prisma.queue.update({\n    where: { shareToken },\n    data: { name: name.trim() },\n  });\n}\n\nexport function deleteQueue({ shareToken }: { shareToken: string }) {\n  return prisma.queue.delete({\n    where: { shareToken },\n  });\n}\n\nexport async function verifyQueueOwnership({\n  shareToken,\n  userId,\n}: {\n  shareToken: string;\n  userId: string;\n}) {\n  const queue = await prisma.queue.findUnique({\n    where: { shareToken },\n    select: { userId: true },\n  });\n\n  if (!queue) {\n    return null;\n  }\n\n  if (queue.userId !== userId) {\n    return null;\n  }\n\n  return queue;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;;;;;;;AAEO,SAAS,gBAAgB,EAAE,MAAM,EAAsB;IAC5D,OAAO,2IAAM,CAAC,KAAK,CAAC,QAAQ,CAAC;QAC3B,OAAO;YAAE;QAAO;QAChB,SAAS;YACP,QAAQ;gBACN,QAAQ;oBAAE,OAAO;gBAAK;YACxB;QACF;QACA,SAAS;YAAE,WAAW;QAAO;IAC/B;AACF;AAEO,SAAS,kBAAkB,EAAE,UAAU,EAA0B;IACtE,OAAO,2IAAM,CAAC,KAAK,CAAC,UAAU,CAAC;QAC7B,OAAO;YAAE;QAAW;QACpB,SAAS;YACP,OAAO;gBACL,SAAS;oBAAE,UAAU;gBAAM;YAC7B;QACF;IACF;AACF;AAEO,SAAS,mBAAmB,EAAE,UAAU,EAA0B;IACvE,OAAO,2IAAM,CAAC,KAAK,CAAC,UAAU,CAAC;QAC7B,OAAO;YAAE;QAAW;QACpB,SAAS;YACP,OAAO;gBACL,SAAS;oBAAE,UAAU;gBAAM;YAC7B;YACA,MAAM;gBACJ,QAAQ;oBACN,IAAI;oBACJ,MAAM;gBACR;YACF;QACF;IACF;AACF;AAEO,SAAS,YAAY,EAC1B,IAAI,EACJ,MAAM,EAIP;IACC,MAAM,aAAa,IAAA,gJAAkB;IACrC,OAAO,2IAAM,CAAC,KAAK,CAAC,MAAM,CAAC;QACzB,MAAM;YACJ,MAAM,KAAK,IAAI;YACf;YACA;QACF;IACF;AACF;AAEO,SAAS,YAAY,EAC1B,UAAU,EACV,IAAI,EAIL;IACC,OAAO,2IAAM,CAAC,KAAK,CAAC,MAAM,CAAC;QACzB,OAAO;YAAE;QAAW;QACpB,MAAM;YAAE,MAAM,KAAK,IAAI;QAAG;IAC5B;AACF;AAEO,SAAS,YAAY,EAAE,UAAU,EAA0B;IAChE,OAAO,2IAAM,CAAC,KAAK,CAAC,MAAM,CAAC;QACzB,OAAO;YAAE;QAAW;IACtB;AACF;AAEO,eAAe,qBAAqB,EACzC,UAAU,EACV,MAAM,EAIP;IACC,MAAM,QAAQ,MAAM,2IAAM,CAAC,KAAK,CAAC,UAAU,CAAC;QAC1C,OAAO;YAAE;QAAW;QACpB,QAAQ;YAAE,QAAQ;QAAK;IACzB;IAEA,IAAI,CAAC,OAAO;QACV,OAAO;IACT;IAEA,IAAI,MAAM,MAAM,KAAK,QAAQ;QAC3B,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 326, "column": 0}, "map": {"version":3,"sources":["file:///Users/devinat1/Desktop/projects/work-queue/apps/web/pages/api/queues/index.ts"],"sourcesContent":["import type { NextApiRequest, NextApiResponse } from \"next\";\nimport { getSession } from \"@helpers/api/auth\";\nimport { fetchUserQueues, createQueue } from \"@helpers/api/db/queues\";\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  if (req.method === \"GET\") {\n    try {\n      const session = await getSession({ req });\n\n      if (!session) {\n        return res.status(401).json({ error: \"Unauthorized\" });\n      }\n\n      const queues = await fetchUserQueues({ userId: session.user.id });\n\n      return res.status(200).json(queues);\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error\";\n      console.error(\"Failed to fetch queues:\", errorMessage, error);\n      return res\n        .status(500)\n        .json({ error: \"Failed to fetch queues.\", details: errorMessage });\n    }\n  }\n\n  if (req.method === \"POST\") {\n    try {\n      const session = await getSession({ req });\n\n      if (!session) {\n        return res.status(401).json({ error: \"Unauthorized\" });\n      }\n\n      const { name } = req.body as { name: string };\n\n      if (!name || name.trim().length === 0) {\n        return res.status(400).json({ error: \"Queue name is required.\" });\n      }\n\n      const queue = await createQueue({ name, userId: session.user.id });\n\n      return res.status(201).json(queue);\n    } catch (error) {\n      console.error(\"Failed to create queue.\", error);\n      return res.status(500).json({ error: \"Failed to create queue.\" });\n    }\n  }\n\n  res.setHeader(\"Allow\", [\"GET\", \"POST\"]);\n  return res.status(405).end();\n}\n"],"names":[],"mappings":";;;;AACA;AACA;;;;;;;;AAEe,eAAe,QAC5B,GAAmB,EACnB,GAAoB;IAEpB,IAAI,IAAI,MAAM,KAAK,OAAO;QACxB,IAAI;YACF,MAAM,UAAU,MAAM,IAAA,4IAAU,EAAC;gBAAE;YAAI;YAEvC,IAAI,CAAC,SAAS;gBACZ,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,OAAO;gBAAe;YACtD;YAEA,MAAM,SAAS,MAAM,IAAA,yJAAe,EAAC;gBAAE,QAAQ,QAAQ,IAAI,CAAC,EAAE;YAAC;YAE/D,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;QAC9B,EAAE,OAAO,OAAO;YACd,MAAM,eACJ,iBAAiB,QAAQ,MAAM,OAAO,GAAG;YAC3C,QAAQ,KAAK,CAAC,2BAA2B,cAAc;YACvD,OAAO,IACJ,MAAM,CAAC,KACP,IAAI,CAAC;gBAAE,OAAO;gBAA2B,SAAS;YAAa;QACpE;IACF;IAEA,IAAI,IAAI,MAAM,KAAK,QAAQ;QACzB,IAAI;YACF,MAAM,UAAU,MAAM,IAAA,4IAAU,EAAC;gBAAE;YAAI;YAEvC,IAAI,CAAC,SAAS;gBACZ,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,OAAO;gBAAe;YACtD;YAEA,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,IAAI;YAEzB,IAAI,CAAC,QAAQ,KAAK,IAAI,GAAG,MAAM,KAAK,GAAG;gBACrC,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,OAAO;gBAA0B;YACjE;YAEA,MAAM,QAAQ,MAAM,IAAA,qJAAW,EAAC;gBAAE;gBAAM,QAAQ,QAAQ,IAAI,CAAC,EAAE;YAAC;YAEhE,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;QAC9B,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2BAA2B;YACzC,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAA0B;QACjE;IACF;IAEA,IAAI,SAAS,CAAC,SAAS;QAAC;QAAO;KAAO;IACtC,OAAO,IAAI,MAAM,CAAC,KAAK,GAAG;AAC5B"}}]
}